//! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.11

use std::{collections::HashMap, marker::PhantomData};

use sea_orm::{entity::prelude::*, *};
use serde::{Deserialize, Serialize};

#[derive(Copy, Clone, Default, Debug, DeriveEntity)]
pub struct Entity;

impl EntityName for Entity {
    fn table_name(&self) -> &str {
        "posts"
    }
}

#[derive(Clone, Debug, PartialEq, DeriveModel, DeriveActiveModel, Eq, Serialize, Deserialize)]
pub struct Model {
    #[serde(skip_deserializing)]
    pub id: i32,
    pub title: String,
    pub text: String,
    pub status: CheckStatus,
    pub params: Params,
    pub kvs: Option<Kvs>,
    pub parent_id: Option<i32>,
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize, EnumIter, DeriveActiveEnum)]
#[serde(rename_all = "snake_case")]
#[sea_orm(
    rs_type = "String",
    db_type = "String(StringLen::N(20))",
    rename_all = "snake_case"
)]
pub enum CheckStatus {
    Pending,
    Running,
    Success,
    Failure,
    Error,
}

#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize, FromJsonQueryResult)]
pub struct Params {
    pub hello: Option<String>,
    pub foo: Option<String>,
}

// #[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize, FromJsonQueryResult)]
// pub type Kvs = Option<HashMap<String, String>>;
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize, FromJsonQueryResult)]
pub struct Kvs(pub HashMap<String, String>);

#[derive(Copy, Clone, Debug, EnumIter, DeriveColumn)]
pub enum Column {
    Id,
    Title,
    Text,
    Status,
    Params,
    Kvs,
    ParentId,
}

#[derive(Copy, Clone, Debug, EnumIter, DerivePrimaryKey)]
pub enum PrimaryKey {
    Id,
}

impl PrimaryKeyTrait for PrimaryKey {
    type ValueType = i32;
    fn auto_increment() -> bool {
        true
    }
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(has_many = "Entity")] // 关键点：必须是 has_many
    Children,

    #[sea_orm(belongs_to = "Entity", from = "Column::ParentId", to = "Column::Id")]
    Parent,
}

impl ColumnTrait for Column {
    type EntityName = Entity;
    fn def(&self) -> ColumnDef {
        match self {
            Self::Id => ColumnType::Integer.def(),
            Self::Title => ColumnType::String(StringLen::N(255u32)).def(),
            Self::Text => ColumnType::String(StringLen::N(255u32)).def(),
            Self::Status => ColumnType::String(StringLen::N(20u32)).def(),
            Self::Params => ColumnType::Json.def(),
            Self::Kvs => ColumnType::Json.def().null(),
            Self::ParentId => ColumnType::Integer.def().null(),
        }
    }
}

impl Related<Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Children.def()
    }
}

pub struct ChildrenLink;

impl Linked for ChildrenLink {
    type FromEntity = Entity;
    type ToEntity = Entity;

    fn link(&self) -> Vec<RelationDef> {
        vec![
            // Relation::Parent.def().rev(),
            Entity::has_many(Entity)
                .from(Column::ParentId)
                .to(Column::Id)
                .into(),
        ]
    }
}

impl ActiveModelBehavior for ActiveModel {}

pub struct Todo<C: ConnectionTrait> {
    _marker: PhantomData<C>,
}

impl<C: ConnectionTrait> Todo<C> {
    async fn create(conn: &C) -> Result<Model, DbErr> {
        let form_data = Model {
            id: 0,
            title: "Test".to_string(),
            text: "Test".to_string(),
            status: CheckStatus::Pending,
            params: Params {
                hello: Some("Hello".to_string()),
                foo: Some("Foo".to_string()),
            },
            kvs: None,
            parent_id: Some(1),
        };
        let res = ActiveModel {
            title: Set(form_data.title.to_owned()),
            text: Set(form_data.text.to_owned()),
            status: Set(form_data.status.to_owned()),
            params: Set(form_data.params.to_owned()),
            parent_id: Set(form_data.parent_id),
            ..Default::default()
        }
        .save(conn)
        .await?;

        res.try_into_model()
    }

    async fn list(conn: &C) -> Result<Vec<Model>, DbErr> {
        Entity::find().order_by_asc(Column::Id).all(conn).await
    }

    async fn create2(conn: &C) -> Result<Model, DbErr> {
        Self::create(conn).await
    }

    async fn list2(conn: &C) -> Result<Vec<Model>, DbErr> {
        Self::list(conn).await
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_create_todo() {
        // get env vars
        dotenvy::dotenv().ok();
        let db_url = std::env::var("DATABASE_URL").expect("DATABASE_URL is not set in .env file");
        let conn = Database::connect(&db_url).await.unwrap();

        let res = Todo::create(&conn).await.unwrap();
        println!("create: {res:#?}");
    }

    #[tokio::test]
    async fn test_list_todos() {
        // get env vars
        dotenvy::dotenv().ok();
        let db_url = std::env::var("DATABASE_URL").expect("DATABASE_URL is not set in .env file");
        let conn = Database::connect(&db_url).await.unwrap();

        let page = 1;
        let posts_per_page = 10;

        let paginator = Entity::find()
            .order_by_asc(Column::Id)
            .paginate(&conn, posts_per_page);
        let num_pages = paginator.num_pages().await.unwrap();

        // Fetch paginated posts
        let posts = paginator
            .fetch_page(page - 1)
            .await
            .map(|p| (p, num_pages))
            .unwrap();

        println!("=> {:#?}", posts);
        println!("=> {}", serde_json::to_string(&posts.0).unwrap());
    }

    #[tokio::test]
    async fn test_list_todos_with_in_empty() {
        tracing_subscriber::fmt()
            .with_max_level(tracing::Level::DEBUG)
            .with_test_writer()
            .init();

        // get env vars
        dotenvy::dotenv().ok();
        let db_url = std::env::var("DATABASE_URL").expect("DATABASE_URL is not set in .env file");
        let mut opt = ConnectOptions::new(db_url);
        opt.sqlx_logging(false) // Disable SQLx log
            .sqlx_logging_level(log::LevelFilter::Info);
        let conn = Database::connect(opt).await.unwrap();

        let empty_ids: Vec<i64> = vec![];
        let posts = Entity::find()
            .filter(Column::Id.is_in(empty_ids))
            .order_by_asc(Column::Id)
            .all(&conn)
            .await
            .unwrap();

        println!("=> {:#?}", posts);
    }

    #[tokio::test]
    async fn test_create_todo_with_kvs() {
        // get env vars
        dotenvy::dotenv().ok();
        let db_url = std::env::var("DATABASE_URL").expect("DATABASE_URL is not set in .env file");
        let conn = Database::connect(&db_url).await.unwrap();

        let form_data = Model {
            id: 0,
            title: "Test".to_string(),
            text: "Test".to_string(),
            status: CheckStatus::Pending,
            params: Params {
                hello: Some("Hello".to_string()),
                foo: Some("Foo".to_string()),
            },
            kvs: {
                let mut map = HashMap::new();
                map.insert("Hello".to_string(), "World".to_string());
                Some(Kvs(map))
            },
            parent_id: None,
        };
        ActiveModel {
            title: Set(form_data.title.to_owned()),
            text: Set(form_data.text.to_owned()),
            status: Set(form_data.status.to_owned()),
            params: Set(form_data.params.to_owned()),
            kvs: Set(form_data.kvs.to_owned()),
            ..Default::default()
        }
        .save(&conn)
        .await
        .unwrap();
    }

    #[tokio::test]
    async fn test_list_todo_with_children() {
        // get env vars
        dotenvy::dotenv().ok();
        let db_url = std::env::var("DATABASE_URL").expect("DATABASE_URL is not set in .env file");
        let conn = Database::connect(&db_url).await.unwrap();

        let page = 1;
        let posts_per_page = 1;
        let id = 1;

        let paginator = Entity::find()
            .filter(Column::Id.eq(id))
            .find_also_linked(ChildrenLink)
            .order_by_asc(Column::Id)
            .paginate(&conn, posts_per_page);
        let num_pages = paginator.num_pages().await.unwrap();

        // Fetch paginated posts
        let posts = paginator
            .fetch_page(page - 1)
            .await
            .map(|p| (p, num_pages))
            .unwrap();

        println!("=> {:#?}", posts);
        println!("=> {}", serde_json::to_string(&posts.0).unwrap());
    }

    #[tokio::test]
    async fn test_list_child_todos() {
        // get env vars
        dotenvy::dotenv().ok();
        let db_url = std::env::var("DATABASE_URL").expect("DATABASE_URL is not set in .env file");
        let conn = Database::connect(&db_url).await.unwrap();

        let posts_per_page = 10;
        let parent_id = 1;

        let q = Entity::find_by_id(parent_id)
            .find_also_linked(ChildrenLink)
            .filter(Column::ParentId.eq(parent_id))
            .order_by_asc(Column::Id)
            .limit(posts_per_page);

        // Fetch paginated posts
        let posts = q.all(&conn).await.unwrap();
        println!("=> {:#?}", posts);
    }

    #[tokio::test]
    async fn test_transaction() {
        // get env vars
        dotenvy::dotenv().ok();
        let db_url = std::env::var("DATABASE_URL").expect("DATABASE_URL is not set in .env file");
        let conn = Database::connect(&db_url).await.unwrap();

        let tx = conn.begin().await.unwrap();

        let p = Todo::create(&tx).await.unwrap();
        println!("=> post:  {p:#?}");
        let ps = Todo::list(&tx).await.unwrap();
        println!("=> posts: {:#?}", ps);

        tx.commit().await.unwrap()
    }

    #[tokio::test]
    async fn test_transaction2() {
        // get env vars
        dotenvy::dotenv().ok();
        let db_url = std::env::var("DATABASE_URL").expect("DATABASE_URL is not set in .env file");
        let conn = Database::connect(&db_url).await.unwrap();

        let tx = conn.begin().await.unwrap();

        let p = Todo::create(&tx).await.unwrap();
        println!("=> post:  {p:#?}");

        let p = Todo::create2(&tx).await.unwrap();
        println!("=> post:  {p:#?}");
        let ps = Todo::list2(&tx).await.unwrap();
        println!("=> posts: {:#?}", ps);

        tx.commit().await.unwrap()
    }
}
